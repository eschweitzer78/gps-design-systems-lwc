import { track } from "lwc";
import OmniscriptTypeahead from "c/sfGpsDsOsrtOmniscriptTypeahead";
import {
  getSendResponseJSON,
  setHttpDebugData
} from "c/sfGpsDsOsrtOmniscriptInternalUtils";
import {
  GoogleApiService,
  GooglePlacesService,
  calculateZoom,
  getCoordinates
} from "c/sfGpsDsOsrtGooglePlacesService";
import { isOffPlatform } from "c/sfGpsDsOsrtOmniscriptRestApi";
import {
  Place,
  COMPONENT_MAPPING,
  GOOGLE_ATTRIBUTION,
  PLACE_DETAIL_FIELDS
} from "./constants";

import tmpl from "./sfGpsDsOsrtOmniscriptPlacesTypeahead.html";

/**
 * The omniscriptPlacesTypeahead component extends the functionality of the omniscriptTypeahead,
 * and utilizes the google places api autocomplete endpoint as it's options source.
 * @module ns/omniscriptPlacesTypeahead
 * @typicalName OmniscriptPlacesTypeahead
 * @extends OmniscriptTypeahead
 */
export default class OmniscriptPlacesTypeahead extends OmniscriptTypeahead {
  /**
   * Css classes applied to the lightning-map element. Used to toggle visibility.
   * @type {string}
   * @scope track (private)
   */
  @track mapClasses;

  /**
   * An array containing the selected place. This is an array because the lightning-map
   * is expecting an array of items for it's map-markers attribute.
   * @type {Place[]}
   * @scope track (private)
   */
  @track selectedPlace = [];

  /**
   * Passed in to the lightning-map element's zoom-level attribute.
   * @type {number}
   * @scope track (private)
   */
  @track zoomLevel = 10;

  /**
   * A reference to to a GooglePlacesService instance. Instantiated in `this.initCompVariables`.
   * @type {GooglePlacesService}
   * @scope private
   */
  _placesService;

  /**
   * This is a hash generated by the google places service, and is used to track billing information on the Google API side.
   * @type {string}
   * @scope private
   */
  _sessionToken;

  /**
   * A reference to the required attribution image.
   * @type {string}
   * @scope private
   */
  _googleAttribution = GOOGLE_ATTRIBUTION;

  /**
   * A reference to the lightning-map lwc. Cached in the initial renderedCallback.
   * @type {LightningElement}
   * @scope private
   */
  _mapComp;

  /**
   * Whether or not to render the dom containing the lightning-map element.
   * @type {boolean}
   */
  _renderMap = true;

  /**
   * If the coordinates have not yet been set, returns the pending promise, otherwise will resolve the cached value.
   * @returns {Promise<any>}
   * @scope private
   */
  getCoordinates() {
    if (!this.coordinates) {
      return this.coordinatesPromise.then((result) => {
        this.coordinates = result;
        return this.coordinates;
      });
    }
    return Promise.resolve(this.coordinates);
  }

  /**
   * A throttled callback bound from OmniscriptTypeahead.initCompVariables.
   * @override OmniscriptTypeahead.handleTypeahead
   * @param {KeyboardEvent} evt
   * @returns {void}
   * @scope private
   */
  handleTypeahead(evt) {
    if (evt.target && this.elementValue !== evt.target.value) {
      this.selectedPlace = [];
      this.hideMap();
      this.dispatchOmniEventUtil(
        this,
        {
          path: this._jsonPath,
          elementId: this._elementId,
          value: null,
          node: "vlcPlace"
        },
        "omniupdatejsondef"
      );
    }
    super.handleTypeahead(evt);
  }

  /**
   * Defines the promise chain used to get/set typeahead options.
   * @override OmniscriptTypeahead.getOptions
   * @scope private
   * @returns {Promise<any>}
   */
  getOptions() {
    return this.getCoordinates()
      .then((result) => {
        let location;

        if (result) {
          location = `${result.latitude},${result.longitude}`;
        }

        return this._placesService.placeAutocomplete(
          this.elementValue,
          location,
          undefined,
          this._sessionToken,
          undefined,
          this._propSetMap.googleAddressCountry
        );
      })
      .then((result) => this.handleResponse(result))
      .then((result) => this.setOptions(result))
      .then((result) => {
        this.sendDataToDebugConsole(
          "placeAutoComplete",
          { input: this.elementValue },
          result,
          this._propSetMap.label
        );
      })
      .catch((reason) => {
        this.sendDataToDebugConsole(
          "placeAutoComplete",
          { input: this.elementValue },
          { ...reason, errorMsg: reason.message },
          this._propSetMap.label
        );
        this.handleError(reason);
      });
  }

  /**
   * Link in the promise storing _sessionToken and trimming back the result.
   * @param {*} data - Data returned from GooglePlacesService.placeAutocomplete.
   * @scope private
   * @returns {Promise<any>}
   */
  handleResponse(data) {
    this.errorMessage = "";
    this._sessionToken = data.sessionToken;
    return data.predictions;
  }

  /**
   * Link in the promise chain that sets results from GooglePlaces.placeAutocomplete.predictions,
   * and formats them for use in the c-sf-gps-ds-osrt-typeahead component.
   * @param {*} data - GooglePlaces.placeAutocomplete.predictions
   * @scope private
   * @returns {void}
   */
  setOptions(data) {
    if (data) {
      this.options = data.map(
        (item) => (item = { name: item.description, item: item })
      );
    } else {
      this.options = [];
    }
    return data;
  }

  /**
   * Called when a selection is made from the base typeahead component.
   * Bound in template.
   * @param {CustomEvent} evt
   * @scope private
   * @returns {Promise<any>}
   */
  handleSelect(evt) {
    evt.stopPropagation();
    this.applyCallResp(evt.detail.name);
    if (evt.detail.item && evt.detail.item.place_id) {
      return this._placesService
        .placeDetails(
          evt.detail.item.place_id,
          PLACE_DETAIL_FIELDS,
          this._sessionToken
        )
        .then((result) => ({
          ...result.result,
          place_id: evt.detail.item.place_id
        }))
        .then((result) => {
          this.sendDataToDebugConsole(
            "placeDetails",
            {
              place_id: evt.detail.item.place_id,
              fields: PLACE_DETAIL_FIELDS
            },
            result,
            this._propSetMap.label
          );
          return result;
        })
        .then((result) => this.applySelection(result))
        .then((result) => this.transformResult(result))
        .then((result) => {
          this.dispatchOmniEventUtil(this, { item: result }, evt.type);
          this.options = [];
        });
    }
    return null;
  }

  /**
   * Takes the selected place from the 'select' event, stores the details in this.selected place,
   *  then shows the map, and calculates the correct zoom.
   * @param {*} placeDetailsResult
   * @returns {Promise<any>}
   */
  applySelection(placeDetailsResult) {
    this.applyCallResp(placeDetailsResult.formatted_address);
    this.selectedPlace = [new Place(placeDetailsResult)];
    if (!this._propSetMap.hideMap && this._mapComp) {
      this.zoomLevel = calculateZoom(
        this._mapComp,
        placeDetailsResult.geometry.viewport
      );
      this.showMap();
    }
    this._sessionToken = undefined;
    return placeDetailsResult;
  }

  /**
   * This step in the promise chain takes the placeDetailsResult and maps the address component
   *  to the structure specified in the os designer.
   * @param {*} placeDetailsResult
   * @scope private
   * @returns {Promise<any>}
   */
  transformResult(placeDetailsResult) {
    const mapping = this._propSetMap.googleTransformation;
    let mapped = {};
    let street = [];

    for (let key in mapping) {
      if (mapping.hasOwnProperty(key)) {
        placeDetailsResult.address_components.forEach((component) => {
          if (component.types.includes(key) && mapping[key]) {
            mapped[mapping[key]] = this.lodashUtil.get(
              component,
              COMPONENT_MAPPING[key],
              component.long_name
            );
          }

          if (mapping.street) {
            if (component.types.includes("street_number"))
              street[0] = component.long_name || "";
            if (component.types.includes("route"))
              street[1] = component.long_name || "";
          }
        });

        if (mapping[key] && !mapped[mapping[key]]) {
          mapped[mapping[key]] = getSendResponseJSON(
            placeDetailsResult,
            key,
            "VlocityNoRootNode"
          );
        }
      }
    }

    if (mapping.street) {
      mapped[mapping.street] = street
        .filter((item) => item !== undefined)
        .join(" ");
    }

    if (!this._propSetMap.hideMap) {
      delete placeDetailsResult.address_components;
      delete placeDetailsResult.vicinity;
      delete placeDetailsResult.types;
      this.dispatchOmniEventUtil(
        this,
        {
          path: this._jsonPath,
          elementId: this._elementId,
          value: placeDetailsResult,
          node: "vlcPlace"
        },
        "omniupdatejsondef"
      );
    }

    return mapped;
  }

  /**
   * Hides the lightning-map component by adding the theme-appropriate 'hide' class.
   * @scope private
   * @returns {void}
   */
  hideMap() {
    this.mapClasses = `${this._theme}-hide`;
  }

  /**
   * Shows the lightning-map component by removing the theme-appropriate 'hide' class.
   * @scope private
   * @returns {void}
   */
  showMap() {
    this.mapClasses = "";
  }

  /**
   * Overwrites inherited sendDataToDebugConsole. Sends data to the Debug Console event handler.
   * @scope private
   * @param {Object} params
   * @param {Object} resp
   * @param {string} label
   * @returns {void}
   */
  sendDataToDebugConsole(endpoint, input, resp, label) {
    const params = {
      sClassName: endpoint,
      sMethodName: "GET",
      input: input
    };
    const debugData = setHttpDebugData(params, resp, label, this.jsonDef);
    debugData.element.type = "web";
    this.dispatchOmniEventUtil(this, debugData, "omniactiondebug");
  }

  // Lifecycle Hooks
  initCompVariables() {
    super.initCompVariables();
    this.coordinatesPromise = getCoordinates().catch((reason) =>
      window.console.log("User location unavailable:", reason.message)
    );
    if (this._propSetMap.hideMap && isOffPlatform() === false)
      this._renderMap = false; //For offplatform the map dom element must render.
    this.hideMap();
  }

  initialRenderCallback() {
    this._mapComp = this.template.querySelector("lightning-map");
    this._placesService = window.hasOwnProperty("google")
      ? new GoogleApiService(this._mapComp)
      : new GooglePlacesService(this._propSetMap.googleMapsAPIKey);

    if (!this._propSetMap.hideMap && this.jsonDef.vlcPlace && this._mapComp) {
      this.selectedPlace = [new Place(this.jsonDef.vlcPlace)];
      this.zoomLevel = calculateZoom(
        this._mapComp,
        this.jsonDef.vlcPlace.geometry.viewport
      );
      this.showMap();
    }
  }

  render() {
    return tmpl;
  }
}
